# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package jellyfish;
use base qw(Exporter);
use base qw(DynaLoader);
package jellyfishc;
bootstrap jellyfish;
package jellyfish;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package jellyfish;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package jellyfish;

*string_mers = *jellyfishc::string_mers;
*string_canonicals = *jellyfishc::string_canonicals;

############# Class : jellyfish::MerDNA ##############

package jellyfish::MerDNA;
use overload
    '""' => sub { $_[0]->__str__()},
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_MerDNA(@_);
    bless $self, $pkg if defined($self);
}

*k = *jellyfishc::MerDNA_k;
*polyA = *jellyfishc::MerDNA_polyA;
*polyC = *jellyfishc::MerDNA_polyC;
*polyG = *jellyfishc::MerDNA_polyG;
*polyT = *jellyfishc::MerDNA_polyT;
*randomize = *jellyfishc::MerDNA_randomize;
*is_homopolymer = *jellyfishc::MerDNA_is_homopolymer;
*shift_left = *jellyfishc::MerDNA_shift_left;
*shift_right = *jellyfishc::MerDNA_shift_right;
*canonicalize = *jellyfishc::MerDNA_canonicalize;
*reverse_complement = *jellyfishc::MerDNA_reverse_complement;
*get_canonical = *jellyfishc::MerDNA_get_canonical;
*get_reverse_complement = *jellyfishc::MerDNA_get_reverse_complement;
*__eq__ = *jellyfishc::MerDNA___eq__;
*__lt__ = *jellyfishc::MerDNA___lt__;
*__gt__ = *jellyfishc::MerDNA___gt__;
*dup = *jellyfishc::MerDNA_dup;
*__str__ = *jellyfishc::MerDNA___str__;
*set = *jellyfishc::MerDNA_set;
*get_base = *jellyfishc::MerDNA_get_base;
*set_base = *jellyfishc::MerDNA_set_base;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_MerDNA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : jellyfish::QueryMerFile ##############

package jellyfish::QueryMerFile;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_QueryMerFile(@_);
    bless $self, $pkg if defined($self);
}

*get = *jellyfishc::QueryMerFile_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_QueryMerFile($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : jellyfish::ReadMerFile ##############

package jellyfish::ReadMerFile;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_ReadMerFile(@_);
    bless $self, $pkg if defined($self);
}

*next_mer = *jellyfishc::ReadMerFile_next_mer;
*mer = *jellyfishc::ReadMerFile_mer;
*count = *jellyfishc::ReadMerFile_count;
*each = *jellyfishc::ReadMerFile_each;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_ReadMerFile($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : jellyfish::HashCounter ##############

package jellyfish::HashCounter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_HashCounter(@_);
    bless $self, $pkg if defined($self);
}

*size = *jellyfishc::HashCounter_size;
*val_len = *jellyfishc::HashCounter_val_len;
*add = *jellyfishc::HashCounter_add;
*update_add = *jellyfishc::HashCounter_update_add;
*get = *jellyfishc::HashCounter_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_HashCounter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : jellyfish::HashSet ##############

package jellyfish::HashSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_HashSet(@_);
    bless $self, $pkg if defined($self);
}

*size = *jellyfishc::HashSet_size;
*add = *jellyfishc::HashSet_add;
*get = *jellyfishc::HashSet_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_HashSet($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : jellyfish::StringMers ##############

package jellyfish::StringMers;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( jellyfish );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = jellyfishc::new_StringMers(@_);
    bless $self, $pkg if defined($self);
}

*next_mer = *jellyfishc::StringMers_next_mer;
*mer = *jellyfishc::StringMers_mer;
*each = *jellyfishc::StringMers_each;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        jellyfishc::delete_StringMers($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package jellyfish;

1;
